#!/bin/bash

destination="$2"

GON_BASIC_BACKUP=(
    "$HOME/Desktop"
    "$HOME/Downloads"
    "$HOME/.mozilla"
    "$HOME/.ssh"
    "$HOME/.cert"
    "$HOME/.var/app/org.remmina.Remmina/data/remmina"
    "$HOME/.var/app/org.remmina.Remmina/config/remmina"
    "$HOME/.var/app/org.mozilla.Thunderbird/.thunderbird"
    "$HOME/Dropbox/Documents"
    "$HOME/Dropbox/Games"
    "$HOME/Dropbox/Pictures"
    "$HOME/Dropbox/Projects"
    "$HOME/Dropbox/Programs"
    "$HOME/Dropbox/Videos"
)

GON_EXTRA=(
    "$HOME/Dropbox/Backup"
    "$HOME/Dropbox/Music"
)

WORK_SETTINGS=(
    "$HOME/.local/MATLAB"
    "$HOME/.local/stata14"
    "$HOME/.local/stata-png-fix"
    # "$HOME/.stata14"
    # "$HOME/.matlab"
)

GON_FULL_BACKUP=("${GON_BASIC_BACKUP[@]}" "${GON_EXTRA[@]}" "${WORK_SETTINGS[@]}")

list_mountpoints() {
    lsblk -no MOUNTPOINTS
}

get_mountpoint() {
    # Asks user to select a /dev/sdX or /dev/nvmeXXX device and
    # returns the selected device.
    local mountpoints number
    local -i n=1
    # Sata and NVME mountpoints array
    mountpoints=($(list_mountpoints | grep -vE "/boot|/$|\[SWAP\]$"))
    lsblk -n >&1 1>&2
    printf "\nPlease select a drive by typing the corresponding number.\n" >&1 1>&2
    for i in "${mountpoints[@]}"; do
        printf "\t%s - %s\n" $n $i >&1 1>&2
        ((n++))
    done
    read -rep "Enter drive's number: " number

    while [[ $(("$number" - 1)) -ge "${#mountpoints[@]}" ]] || [ -z "$number" ]; do
        echo "Number '$number' is not an available option." >&1 1>&2
        unset number
        read -rep "Select a drive by typing the corresponding number: " number
    done

    echo "${mountpoints[$(("$number" - 1))]}"
}

# ask_delete() {

#     prompt=$(
# 		cat <<-EOF
# 		Backup interrupted.
# 		Would you like to delete $backup_dir ? [y/N]:
# 		EOF
#     )

#     read -rep "$prompt" reply
#     if [[ $reply =~ ^[Yy]$ ]]; then
#         sudo rm -rf "$backup_dir"
#     fi
# }

filesystem_check() {
    # 'local' must be used
    local source_dir="$1"
    local destination="$2"

    # TODO: Check if destination exists before using dirname?
    local destination=$(dirname "$destination")
    # Expecting a directory inside an extrenal drive.
    # If the destination is "/mnt/drive" the use of "dirname" fails.

    if df -P -- "$destination" "$source_dir" | awk 'NR==2 {dev1=$1} NR==3 {exit($1!=dev1)}'; then
        echo "$destination and $source_dir are on the same filesystem"
        # rmdir "$source_dir" 2>/dev/null || echo "$source_dir is not empty."
        exit 1
    fi
}

_rsync() {
    sudo rsync -aAXH --relative -h --info=progress2 --prune-empty-dirs --delete $@
    # rsync -aAXH -h --info=progress2 --prune-empty-dirs --delete $@
}

convertsecs() {
    ((h = ${1} / 3600))
    ((m = (${1} % 3600) / 60))
    ((s = ${1} % 60))
    # TODO: move printf
    printf "Backup ended in %02d:%02d:%02d\n" $h $m $s
}

dconf_dump() {
    dconf dump / | sudo tee $1/dconf_FULL.ini > /dev/null
    [[ `command -v dump_dconf_extension_settings` ]] && dump_dconf_extension_settings &&
        _rsync "$HOME/.config/dconf" "$1"

}

gon_backup() {

    local start_="$(date -u +%s)"
    local start_time=$(date +%F-%T)
    local destination="$2"

    local size="$1"
    case "$size" in
    small)
        data_sources_list=("${GON_BASIC_BACKUP[@]}")
        ;;

    big | full)
        data_sources_list=("${GON_FULL_BACKUP[@]}")
        ;;

    *)
        printf "Available arguments small|big|full "
        printf "Nothing was/will be backed up\n\n"
        exit
        ;;
    esac

    for dir in "${data_sources_list[@]}"; do
        filesystem_check "$dir" "$destination"
    done

    printf "%s\nStarting backup to: %s\n\n" "$start_time" "$destination"
    sudo rsync -aAXH --relative -h --info=progress2 --prune-empty-dirs ${data_sources_list[@]} "$destination" &&
        dconf_dump $destination &&
        sudo btrfs subvolume snapshot "$destination" "${destination}_$start_time" &&
        echo "Snapshot created"

    end_="$(date -u +%s)"
    convertsecs $((end_ - start_))
}

# if destination not in mountpoints ask again.
main() {
    [ -z $destination ] && destination="$(get_mountpoint)"

    destination="$destination/backups"

    printf "Backing up '%s' to '%s' with the following argument:\n'%s'" $(hostname) $destination "$1"
    read -r

    mkdir -p $destination

    case $(hostname) in
    gon | p14s)
        gon_backup "$1" "$destination/$(hostname)_backup"
        ;;
    *)
        printf "Nothing was/will be backed up\n\n"
        ;;
    esac

    # tar \
    # --directory="$HOME/.var/app/org.mozilla.Thunderbird/" \
    # -acf \
    # "${destination}/thunderbird-$(hostname)-$(date +%F).tar.zst" \
    # .thunderbird

}

# INTERRUPTED='False'

main "$1" "$2"

# trap 'ask_delete; exit 2' INT TERM
